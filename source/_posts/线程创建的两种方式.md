---
title: 线程创建两种方式的比较
type: categories
categories: 编程
tags:
  - Java
  - 线程
copyright: true
abbrlink: c10dafe5
date: 2017-05-08 00:00:00
---



### 线程创建的两种方式

#### 继承Thread类

```java
class DemoThread extends Thread{
  ......
    @Override
    public void run(){
      ......
    }
}
DemoThread dt = new DemoThread();
dt.start();
```
<!-- more -->
#### 实现Runnable接口

```java
class DemoRunnable implements Runnable{
  ......
    @Override
    public void run(){
      ......
    }
}
DemoRunnable dr = new DemoRunnable();
Thread td = new Thread(dr);
td.start();
```

我们知道，在Java中是单继承机制，即一个子类只能继承自一个父类，故采用继承Thread类的方法会有缺陷，而Runnable的资源可以被多个线程所共享，适合多个线程处理**同一资源**的情况，接下来通过一个具体的例子来讲解一下：

### 模拟火车站售票

![](https://ws1.sinaimg.cn/large/ba22af52gy1ffham96leyj20tw0dcacw.jpg)

现在还剩下5张火车票，共有3个售票窗口售卖这5张票，我们看看分别用两种方式来模拟会出现什么结果

### Thread模拟

```java
public class DemoThread extends Thread{
    private int tickets = 5;        //火车票总数
    private String name;            //窗口(线程)名字
    public DemoThread(String name){
        this.name = name;
    }
    public void run(){
        while(tickets > 0){
            tickets --;        //票还有富余，卖掉一张
            System.out.println(name+
                               "出票1张,剩余票数"+ tickets);
        }
    }

    public static void main(String[] args){
        //创建3个线程，模拟三个窗口
        DemoThread dt1 = new DemoThread("窗口1");
        DemoThread dt2 = new DemoThread("窗口2");
        DemoThread dt3 = new DemoThread("窗口3");
        //进程启动
        dt1.start();
        dt2.start();
        dt3.start();
    }
}
```

首先看看Thread的运行结果：

> 窗口1出票1张,剩余票数4
> 窗口1出票1张,剩余票数3
> 窗口1出票1张,剩余票数2
> 窗口1出票1张,剩余票数1
> 窗口1出票1张,剩余票数0
> 窗口2出票1张,剩余票数4
> 窗口2出票1张,剩余票数3
> 窗口2出票1张,剩余票数2
> 窗口3出票1张,剩余票数4
> 窗口2出票1张,剩余票数1
> 窗口3出票1张,剩余票数3
> 窗口3出票1张,剩余票数2
> 窗口3出票1张,剩余票数1
> 窗口3出票1张,剩余票数0
> 窗口2出票1张,剩余票数0

分析一下这个结果：窗口1抢占到了CPU，卖了5张票，随后窗口2和窗口3居然也卖了5张票，也就是说这三个窗口一共卖了15张票，这显然不是我们需要的结果

### Runnable模拟

```java
public class DemoRunnable implements Runnable{
    private int tickets = 5;

    public void run(){
        while(tickets > 0){
            tickets --;         //票数有富余，出票1张
            System.out.println(Thread.currentThread().getName()+
                               "出票,剩余票数"+ -- tickets);
        }
    }

    public static void main(String[] args){
        DemoRunnable dr = new DemoRunnable();
        Thread t1 = new Thread(dr, "窗口1");
        Thread t2 = new Thread(dr, "窗口2");
        Thread t3 = new Thread(dr, "窗口3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

接下来看看Runnable的运行结果：

>窗口1出票,剩余票数4
>窗口3出票,剩余票数2
>窗口3出票,剩余票数0
>窗口2出票,剩余票数3
>窗口1出票,剩余票数1

这就正常了，三个窗口一共售卖了5张票，但是我们看出票的顺序，4-2-0-3-1，为什么不是4-3-2-1-0呢？

这是因为Java的线程的执行时机是不确定的，我们分析一下结果：

1. t1首先获得了CPU的资源：窗口1开始出票，并打印剩余票数4，让出资源；
2. t2其次获得了CPU的资源：窗口2开始出票，此时剩余票数为3，在准备打印剩余票数的时候出现了一点小问题；
3. t3出现并抢占CPU的资源：在窗口2出了票但是还没打印结果的时候，这个时候t3开始出票，并且打印出剩余票数2；
4. t1再次获得了CPU的资源：在窗口1出了票，在准备打印出剩余票数1的时候，又被窗口3抢得了资源；
5. t3再次获得了CPU的资源：在窗口3出了票并打印出剩余票数0，让出资源；
6. t2终于获得了资源，打印出剩余票数3，让出资源；
7. t1最后获得了资源，开始打印出剩余票数1，结束；

### 总结

在程序开发中只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口比继承Thread类有如下好处：

1. **避免单继承的局限**，**一个类可以继承多个接口；**
2. **适合于资源的共享。**
